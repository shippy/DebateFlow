<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DebateFlow Annotation Tool</title>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
<style>
  :root {
    --bg: #f8f9fa;
    --surface: #ffffff;
    --border: #dee2e6;
    --text: #212529;
    --muted: #6c757d;
    --primary: #2563eb;
    --primary-hover: #1d4ed8;
    --danger: #dc3545;
    --success: #198754;
    --warn: #ffc107;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: var(--bg); color: var(--text); line-height: 1.5; }

  .header { background: var(--surface); border-bottom: 1px solid var(--border); padding: 12px 24px; display: flex; align-items: center; justify-content: space-between; position: sticky; top: 0; z-index: 10; }
  .header h1 { font-size: 16px; font-weight: 600; }
  .header .progress { font-size: 14px; color: var(--muted); }
  .header .annotator { font-size: 13px; color: var(--muted); }

  .setup { max-width: 500px; margin: 80px auto; text-align: center; padding: 40px; background: var(--surface); border-radius: 8px; border: 1px solid var(--border); }
  .setup h2 { margin-bottom: 16px; }
  .setup input[type="text"] { padding: 8px 12px; border: 1px solid var(--border); border-radius: 4px; font-size: 14px; width: 200px; margin-bottom: 16px; }
  .setup .drop-zone { border: 2px dashed var(--border); border-radius: 8px; padding: 40px 20px; margin: 16px 0; cursor: pointer; transition: border-color 0.2s; }
  .setup .drop-zone:hover, .setup .drop-zone.dragover { border-color: var(--primary); }
  .setup .drop-zone p { color: var(--muted); font-size: 14px; }
  .setup button { background: var(--primary); color: white; border: none; padding: 8px 20px; border-radius: 4px; font-size: 14px; cursor: pointer; }
  .setup button:hover { background: var(--primary-hover); }
  .setup button:disabled { opacity: 0.5; cursor: not-allowed; }

  .main { display: grid; grid-template-columns: 1fr 380px; gap: 0; height: calc(100vh - 49px); }
  .transcript { padding: 24px; overflow-y: auto; }
  .resolution { font-size: 15px; font-weight: 600; margin-bottom: 20px; padding: 12px 16px; background: #eef2ff; border-radius: 6px; border-left: 4px solid var(--primary); }

  .turn { margin-bottom: 16px; padding: 16px; background: var(--surface); border-radius: 6px; border: 1px solid var(--border); }
  .turn-header { font-size: 13px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; }
  .turn-header.aff { color: #2563eb; }
  .turn-header.neg { color: #dc2626; }
  .turn-text { font-size: 14px; line-height: 1.6; }
  .turn-text p { margin-bottom: 0.6em; }
  .turn-text ul, .turn-text ol { margin: 0.4em 0 0.6em 1.5em; }
  .turn-text h1, .turn-text h2, .turn-text h3 { margin: 0.8em 0 0.3em; font-size: 14px; font-weight: 700; }
  .turn-text strong { font-weight: 700; }
  .turn-text blockquote { border-left: 3px solid var(--border); padding-left: 12px; color: var(--muted); margin: 0.4em 0; }

  .scoring { background: var(--surface); border-left: 1px solid var(--border); padding: 24px; overflow-y: auto; }
  .scoring h3 { font-size: 14px; font-weight: 600; margin-bottom: 16px; }

  .winner-section { margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--border); }
  .winner-section label { display: flex; align-items: center; gap: 8px; font-size: 14px; padding: 4px 0; cursor: pointer; }
  .winner-section input[type="radio"] { cursor: pointer; }

  .dim-section { margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid #f0f0f0; }
  .dim-title { font-size: 13px; font-weight: 600; margin-bottom: 2px; display: flex; align-items: center; gap: 6px; }
  .dim-title .help { font-size: 11px; color: var(--muted); cursor: help; font-weight: 400; }
  .dim-def { font-size: 11px; color: var(--muted); margin-bottom: 8px; font-style: italic; }
  .score-row { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; font-size: 13px; }
  .score-row .side-label { width: 32px; font-weight: 600; font-size: 12px; }
  .score-row .side-label.aff { color: #2563eb; }
  .score-row .side-label.neg { color: #dc2626; }
  .score-btn { min-width: 56px; height: 28px; padding: 0 8px; border: 1px solid var(--border); background: var(--surface); border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600; transition: all 0.15s; }
  .score-btn:hover { border-color: var(--primary); }
  .score-btn.selected { background: var(--primary); color: white; border-color: var(--primary); }
  .score-btn.incomplete { border-color: var(--danger); }

  .justification { margin-top: 16px; }
  .justification textarea { width: 100%; height: 80px; border: 1px solid var(--border); border-radius: 4px; padding: 8px; font-size: 13px; font-family: inherit; resize: vertical; }
  .justification label { font-size: 13px; font-weight: 600; display: block; margin-bottom: 4px; }

  .save-btn { margin-top: 16px; width: 100%; padding: 10px; background: var(--success); color: white; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer; }
  .save-btn:hover { background: #157347; }
  .save-btn:disabled { background: var(--muted); cursor: not-allowed; }

  .keyboard-help { margin-top: 12px; font-size: 11px; color: var(--muted); }
  .keyboard-help kbd { background: #eee; padding: 1px 5px; border-radius: 3px; border: 1px solid #ccc; font-family: monospace; }

  .turn-playing { border-color: var(--primary); box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2); }
  .turn-loading { border-color: var(--warn); box-shadow: 0 0 0 2px rgba(255, 193, 7, 0.2); animation: pulse-border 1.5s ease-in-out infinite; }
  @keyframes pulse-border { 0%, 100% { box-shadow: 0 0 0 2px rgba(255, 193, 7, 0.15); } 50% { box-shadow: 0 0 0 4px rgba(255, 193, 7, 0.3); } }

  .turn-actions { display: flex; align-items: center; gap: 8px; margin-top: 10px; }
  .play-btn { display: inline-flex; align-items: center; gap: 4px; padding: 4px 10px; border: 1px solid var(--border); background: var(--surface); border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 500; color: var(--text); transition: all 0.15s; }
  .play-btn:hover { border-color: var(--primary); color: var(--primary); }
  .play-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .play-btn.loading { color: var(--muted); }

  .audio-controls { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; padding: 10px 16px; background: var(--surface); border-radius: 6px; border: 1px solid var(--border); }
  .audio-controls .play-all-btn { display: inline-flex; align-items: center; gap: 4px; padding: 6px 14px; border: 1px solid var(--primary); background: var(--surface); border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 600; color: var(--primary); transition: all 0.15s; }
  .audio-controls .play-all-btn:hover { background: var(--primary); color: white; }
  .audio-controls .play-all-btn.active { background: var(--primary); color: white; }
  .audio-controls .play-all-btn.loading { background: var(--warn); color: var(--text); border-color: var(--warn); animation: pulse-bg 1.5s ease-in-out infinite; }
  @keyframes pulse-bg { 0%, 100% { opacity: 0.85; } 50% { opacity: 1; } }
  .audio-controls .audio-status { font-size: 12px; color: var(--muted); font-style: italic; }
  .audio-controls select { padding: 4px 8px; border: 1px solid var(--border); border-radius: 4px; font-size: 12px; background: var(--surface); }
  .audio-controls .speed-label { font-size: 12px; color: var(--muted); }

  .server-load { margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border); }
  .server-load button { background: var(--surface); color: var(--primary); border: 1px solid var(--primary); }
  .server-load button:hover { background: var(--primary); color: white; }
  .server-load .status { font-size: 12px; color: var(--muted); margin-top: 6px; }

  .done { max-width: 500px; margin: 80px auto; text-align: center; padding: 40px; background: var(--surface); border-radius: 8px; border: 1px solid var(--border); }
  .done h2 { color: var(--success); margin-bottom: 12px; }
</style>
</head>
<body x-data="annotationApp()" @keydown.window="handleKeydown($event)">

  <!-- Header -->
  <div class="header" x-show="state !== 'setup'">
    <h1>DebateFlow Annotation</h1>
    <span class="progress" x-show="state === 'annotating'" x-text="`Debate ${currentIndex + 1} of ${debates.length}`"></span>
    <div style="display: flex; align-items: center; gap: 16px;">
      <a href="/review" style="font-size: 13px; color: var(--primary); text-decoration: none;">Review</a>
      <span class="annotator" x-text="`Annotator: ${annotatorId}`"></span>
    </div>
  </div>

  <!-- Setup Screen -->
  <div class="setup" x-show="state === 'setup'">
    <h2>DebateFlow Annotation Tool</h2>
    <p style="color: var(--muted); margin-bottom: 20px; font-size: 14px;">Load debate JSON files for blind annotation.</p>

    <div style="margin-bottom: 16px;">
      <label style="font-size: 13px; font-weight: 600; display: block; margin-bottom: 4px;">Annotator ID</label>
      <input type="text" x-model="annotatorId" placeholder="e.g. SP" @keydown.enter="$refs.filePicker.click()">
    </div>

    <div class="drop-zone"
         :class="{ dragover: isDragging }"
         @click="$refs.filePicker.click()"
         @dragover.prevent="isDragging = true"
         @dragleave.prevent="isDragging = false"
         @drop.prevent="handleDrop($event)">
      <p>Drop debate JSON files here or click to browse</p>
      <p x-show="debates.length > 0" style="color: var(--success); margin-top: 8px;" x-text="`${debates.length} debate(s) loaded`"></p>
    </div>
    <input type="file" x-ref="filePicker" multiple accept=".json" style="display:none" @change="handleFiles($event)">

    <button :disabled="!annotatorId.trim() || debates.length === 0" @click="startAnnotating()">
      Start Annotating
    </button>

    <div class="server-load">
      <button @click="loadFromServer()" :disabled="serverLoading">
        <span x-text="serverLoading ? 'Loading...' : 'Load from Server'"></span>
      </button>
      <div class="status" x-show="serverStatus" x-text="serverStatus"></div>
    </div>
  </div>

  <!-- Annotation Screen -->
  <template x-if="state === 'annotating'">
    <div class="main">
      <!-- Left: Transcript -->
      <div class="transcript">
        <div class="resolution" x-text="currentDebate().metadata.resolution"></div>

        <!-- Audio Controls -->
        <div class="audio-controls">
          <button class="play-all-btn" :class="{ active: playingAll && playingTurnIndex >= 0, loading: playingAll && loadingTurnIndex >= 0 }" @click="togglePlayAll()">
            <span x-text="playAllLabel()"></span>
          </button>
          <span class="audio-status" x-show="playingTurnIndex >= 0 || loadingTurnIndex >= 0" x-text="audioStatusText()"></span>
          <span class="speed-label">Speed:</span>
          <select x-model="playbackSpeed" @change="updatePlaybackSpeed()">
            <option value="1">1x</option>
            <option value="1.25">1.25x</option>
            <option value="1.5">1.5x</option>
          </select>
        </div>

        <template x-for="(turn, ti) in currentDebate().turns" :key="turn.role">
          <div class="turn" :class="{ 'turn-playing': playingTurnIndex === ti, 'turn-loading': loadingTurnIndex === ti }">
            <div class="turn-header" :class="turn.speaker">
              <span x-text="turnLabel(turn)"></span>
            </div>
            <div class="turn-text" x-html="renderMarkdown(turn.text)"></div>
            <div class="turn-actions">
              <button class="play-btn" :class="{ loading: loadingTurnIndex === ti }" :disabled="loadingTurnIndex === ti" @click="toggleTurn(ti)">
                <span x-text="playingTurnIndex === ti ? 'Pause' : (loadingTurnIndex === ti ? 'Loading...' : 'Play')"></span>
              </button>
            </div>
          </div>
        </template>
      </div>

      <!-- Right: Scoring -->
      <div class="scoring">
        <h3>Scoring</h3>

        <!-- Winner -->
        <div class="winner-section">
          <div style="font-size: 13px; font-weight: 600; margin-bottom: 6px;">Overall Winner</div>
          <label><input type="radio" value="aff" x-model="form.winner"> Affirmative</label>
          <label><input type="radio" value="neg" x-model="form.winner"> Negative</label>
        </div>

        <!-- Dimensions -->
        <template x-for="(dim, di) in dimensions" :key="dim.key">
          <div class="dim-section">
            <div class="dim-title">
              <span x-text="dim.label"></span>
            </div>
            <div class="dim-def" x-text="dim.definition"></div>
            <div class="score-row">
              <span class="side-label aff">AFF</span>
              <template x-for="v in [{n:1,l:'Weak'},{n:2,l:'OK'},{n:3,l:'Strong'}]" :key="'aff'+di+v.n">
                <button class="score-btn"
                        :class="{ selected: form.scores[dim.key]?.aff === v.n, incomplete: showIncomplete && !form.scores[dim.key]?.aff }"
                        @click="setScore(dim.key, 'aff', v.n)"
                        x-text="v.l"></button>
              </template>
            </div>
            <div class="dim-def" x-show="dim.guidance && dim.guidance[currentDebate().metadata.category]" x-text="dim.guidance?.[currentDebate().metadata.category]?.aff" style="margin-top: -4px; margin-bottom: 4px;"></div>
            <div class="score-row">
              <span class="side-label neg">NEG</span>
              <template x-for="v in [{n:1,l:'Weak'},{n:2,l:'OK'},{n:3,l:'Strong'}]" :key="'neg'+di+v.n">
                <button class="score-btn"
                        :class="{ selected: form.scores[dim.key]?.neg === v.n, incomplete: showIncomplete && !form.scores[dim.key]?.neg }"
                        @click="setScore(dim.key, 'neg', v.n)"
                        x-text="v.l"></button>
              </template>
            </div>
            <div class="dim-def" x-show="dim.guidance && dim.guidance[currentDebate().metadata.category]" x-text="dim.guidance?.[currentDebate().metadata.category]?.neg" style="margin-top: -4px;"></div>
          </div>
        </template>

        <!-- Justification -->
        <div class="justification">
          <label>Winner Justification</label>
          <textarea x-model="form.justification" placeholder="Why did this side win?"></textarea>
        </div>

        <!-- Save -->
        <button class="save-btn" :disabled="!isComplete()" @click="saveAndNext()">
          <span x-text="currentIndex < debates.length - 1 ? 'Save & Next' : 'Save & Finish'"></span>
        </button>

        <div class="keyboard-help">
          <kbd>1</kbd><kbd>2</kbd><kbd>3</kbd> score focused dimension &middot;
          <kbd>Tab</kbd> next field &middot;
          <kbd>Ctrl+Enter</kbd> save
        </div>
      </div>
    </div>
  </template>

  <!-- Done Screen -->
  <div class="done" x-show="state === 'done'">
    <h2>Annotation Complete</h2>
    <p x-text="`You annotated ${debates.length} debate(s). All files have been downloaded.`"></p>
    <button style="margin-top: 16px; background: var(--primary); color: white; border: none; padding: 8px 20px; border-radius: 4px; cursor: pointer;" @click="reset()">Start New Session</button>
  </div>

<script>
function annotationApp() {
  return {
    state: 'setup',
    annotatorId: '',
    debates: [],
    currentIndex: 0,
    isDragging: false,
    showIncomplete: false,
    activeDimIndex: 0,
    activeSide: 'aff',

    // Server loading
    serverLoading: false,
    serverStatus: '',

    // Audio state
    audio: null,
    playingTurnIndex: -1,
    loadingTurnIndex: -1,
    playingAll: false,
    playbackSpeed: '1',

    dimensions: [
      { key: 'clash_engagement', label: 'Clash Engagement', definition: 'Did each side address the opponent\'s arguments or talk past them?' },
      { key: 'burden_fulfillment', label: 'Burden Fulfillment', definition: 'Did each side adequately support their core claims and meet their argumentative obligations?', guidance: {
        policy: { aff: 'Did AFF demonstrate a need for change and show the proposal solves it?', neg: 'Did NEG defend the status quo or show the proposal causes more harm?' },
        values: { aff: 'Did AFF show that the value or principle they champion should take precedence?', neg: 'Did NEG show the competing value takes priority or that AFF\'s framing is flawed?' },
        empirical: { aff: 'Did AFF provide sufficient evidence that the claim is true?', neg: 'Did NEG provide sufficient evidence that the claim is false or unsupported?' },
      }},
      { key: 'rebuttal_quality', label: 'Rebuttal Quality', definition: 'Specificity and depth of refutations — targeting weak premises vs. asserting disagreement.' },
      { key: 'argument_extension', label: 'Argument Extension', definition: 'Did arguments develop across turns, or merely repeat the opening?' },
      { key: 'strategic_adaptation', label: 'Strategic Adaptation', definition: 'Did speakers adjust their approach based on the opponent\'s actual moves?' },
    ],

    form: {
      winner: null,
      scores: {},
      justification: '',
    },

    init() {
      this.resetForm();
    },

    resetForm() {
      this.form = {
        winner: null,
        scores: {},
        justification: '',
      };
      this.dimensions.forEach(d => {
        this.form.scores[d.key] = { aff: null, neg: null };
      });
      this.showIncomplete = false;
      this.activeDimIndex = 0;
      this.activeSide = 'aff';
    },

    handleFiles(event) {
      this.loadFiles(Array.from(event.target.files));
    },

    handleDrop(event) {
      this.isDragging = false;
      const files = Array.from(event.dataTransfer.files).filter(f => f.name.endsWith('.json'));
      this.loadFiles(files);
    },

    async loadFiles(files) {
      for (const file of files) {
        try {
          const text = await file.text();
          const data = JSON.parse(text);
          if (data.metadata && data.turns) {
            this.debates.push(data);
          }
        } catch (e) {
          console.warn(`Skipped ${file.name}: ${e.message}`);
        }
      }
    },

    startAnnotating() {
      if (!this.annotatorId.trim() || this.debates.length === 0) return;
      this.currentIndex = 0;
      this.resetForm();
      this.state = 'annotating';
    },

    currentDebate() {
      return this.debates[this.currentIndex] || { metadata: { resolution: '' }, turns: [] };
    },

    renderMarkdown(text) {
      return marked.parse(text || '');
    },

    turnLabel(turn) {
      const sideLabel = turn.speaker === 'aff' ? 'Affirmative' : 'Negative';
      const roleLabels = { opening: 'Opening', response: 'Response', rebuttal: 'Rebuttal', closing: 'Closing' };
      return `${sideLabel} — ${roleLabels[turn.role] || turn.role}`;
    },

    setScore(dimKey, side, value) {
      this.form.scores[dimKey][side] = value;
    },

    isComplete() {
      if (!this.form.winner) return false;
      if (!this.form.justification.trim()) return false;
      for (const dim of this.dimensions) {
        const s = this.form.scores[dim.key];
        if (!s || !s.aff || !s.neg) return false;
      }
      return true;
    },

    saveAndNext() {
      if (!this.isComplete()) {
        this.showIncomplete = true;
        return;
      }

      const debate = this.currentDebate();
      const annotation = {
        debate_id: debate.metadata.debate_id,
        annotator_id: this.annotatorId.trim(),
        winner: this.form.winner,
        winner_justification: this.form.justification.trim(),
        dimension_scores: this.dimensions.map(d => ({
          dimension: d.key,
          aff_score: this.form.scores[d.key].aff,
          neg_score: this.form.scores[d.key].neg,
        })),
        annotated_at: new Date().toISOString(),
        annotation_version: '0.1.0',
      };

      // Download annotation JSON
      const blob = new Blob([JSON.stringify(annotation, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${annotation.debate_id}_${annotation.annotator_id}.json`;
      a.click();
      URL.revokeObjectURL(url);

      // Move to next or finish
      this.stopAudio();
      if (this.currentIndex < this.debates.length - 1) {
        this.currentIndex++;
        this.resetForm();
        // Scroll transcript to top
        const transcript = document.querySelector('.transcript');
        if (transcript) transcript.scrollTop = 0;
      } else {
        this.state = 'done';
      }
    },

    handleKeydown(event) {
      if (this.state !== 'annotating') return;

      // Ctrl+Enter to save
      if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
        event.preventDefault();
        this.saveAndNext();
        return;
      }

      // Don't intercept keys when typing in textarea
      if (event.target.tagName === 'TEXTAREA' || event.target.tagName === 'INPUT') return;

      // 1/2/3 to set score for active dimension
      if (['1', '2', '3'].includes(event.key)) {
        event.preventDefault();
        const dim = this.dimensions[this.activeDimIndex];
        if (dim) {
          this.setScore(dim.key, this.activeSide, parseInt(event.key));
          // Auto-advance: aff -> neg -> next dimension aff
          if (this.activeSide === 'aff') {
            this.activeSide = 'neg';
          } else {
            this.activeSide = 'aff';
            if (this.activeDimIndex < this.dimensions.length - 1) {
              this.activeDimIndex++;
            }
          }
        }
        return;
      }

      // Arrow keys to navigate dimensions
      if (event.key === 'ArrowUp' && this.activeDimIndex > 0) {
        event.preventDefault();
        this.activeDimIndex--;
      }
      if (event.key === 'ArrowDown' && this.activeDimIndex < this.dimensions.length - 1) {
        event.preventDefault();
        this.activeDimIndex++;
      }
      // a/n to pick winner
      if (event.key === 'a') { this.form.winner = 'aff'; }
      if (event.key === 'n') { this.form.winner = 'neg'; }
    },

    // --- Server loading ---
    async loadFromServer() {
      this.serverLoading = true;
      this.serverStatus = '';
      try {
        const ann = this.annotatorId.trim();
        const url = ann ? `/api/debates?annotator=${encodeURIComponent(ann)}` : '/api/debates';
        const res = await fetch(url);
        if (!res.ok) throw new Error('Server not available');
        const files = await res.json();
        if (files.length === 0) {
          this.serverStatus = 'No debates found on server.';
          this.serverLoading = false;
          return;
        }
        let loaded = 0;
        for (const name of files) {
          try {
            const r = await fetch(`/output/debates/${name}`);
            const data = await r.json();
            if (data.metadata && data.turns) {
              // Avoid duplicates
              if (!this.debates.some(d => d.metadata.debate_id === data.metadata.debate_id)) {
                this.debates.push(data);
                loaded++;
              }
            }
          } catch (e) {
            console.warn(`Skipped ${name}: ${e.message}`);
          }
        }
        this.serverStatus = ann
          ? `Loaded ${loaded} unannotated debate(s) from server.`
          : `Loaded ${loaded} debate(s) from server.`;
      } catch (e) {
        this.serverStatus = 'Could not reach server. Start it with: uv run debateflow serve';
      }
      this.serverLoading = false;
    },

    // --- Audio playback ---
    stopAudio() {
      if (this.audio) {
        this.audio.pause();
        this.audio = null;
      }
      this.playingTurnIndex = -1;
      this.loadingTurnIndex = -1;
      this.playingAll = false;
    },

    updatePlaybackSpeed() {
      if (this.audio) {
        this.audio.playbackRate = parseFloat(this.playbackSpeed);
      }
    },

    async playTurn(turnIndex) {
      const debate = this.currentDebate();
      const turn = debate.turns[turnIndex];
      if (!turn) return;

      this.loadingTurnIndex = turnIndex;

      try {
        const res = await fetch('/api/tts', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            debate_id: debate.metadata.debate_id,
            turn_index: turnIndex,
            speaker: turn.speaker,
            text: turn.text,
          }),
        });

        if (!res.ok) {
          const err = await res.json().catch(() => ({ error: res.statusText }));
          console.error('TTS error:', err);
          this.loadingTurnIndex = -1;
          this.playingAll = false;
          return;
        }

        const data = await res.json();
        this.loadingTurnIndex = -1;

        // Create and play audio
        this.audio = new Audio(data.url);
        this.audio.playbackRate = parseFloat(this.playbackSpeed);
        this.playingTurnIndex = turnIndex;

        this.audio.addEventListener('ended', () => {
          const wasPlayingAll = this.playingAll;
          this.playingTurnIndex = -1;
          this.audio = null;

          // If playing all, advance to next turn
          if (wasPlayingAll) {
            const nextIndex = turnIndex + 1;
            if (nextIndex < debate.turns.length) {
              this.playTurn(nextIndex);
            } else {
              this.playingAll = false;
            }
          }
        });

        await this.audio.play();
      } catch (e) {
        console.error('Audio playback failed:', e);
        this.loadingTurnIndex = -1;
        this.playingTurnIndex = -1;
        this.playingAll = false;
      }
    },

    toggleTurn(turnIndex) {
      // If this turn is already playing, pause it
      if (this.playingTurnIndex === turnIndex && this.audio) {
        this.stopAudio();
        return;
      }
      // Stop anything currently playing
      this.stopAudio();
      this.playTurn(turnIndex);
    },

    playAllLabel() {
      if (!this.playingAll) return 'Play All';
      if (this.loadingTurnIndex >= 0) return 'Loading...';
      return 'Stop All';
    },

    audioStatusText() {
      const debate = this.currentDebate();
      const idx = this.loadingTurnIndex >= 0 ? this.loadingTurnIndex : this.playingTurnIndex;
      if (idx < 0 || !debate.turns[idx]) return '';
      const turn = debate.turns[idx];
      const side = turn.speaker === 'aff' ? 'Aff' : 'Neg';
      const roles = { opening: 'Opening', response: 'Response', rebuttal: 'Rebuttal', closing: 'Closing' };
      const role = roles[turn.role] || turn.role;
      if (this.loadingTurnIndex >= 0) return `Synthesizing ${side} ${role}...`;
      return `Playing ${side} ${role}`;
    },

    togglePlayAll() {
      if (this.playingAll) {
        this.stopAudio();
        return;
      }
      this.stopAudio();
      this.playingAll = true;
      this.playTurn(0);
    },

    reset() {
      this.stopAudio();
      this.state = 'setup';
      this.debates = [];
      this.currentIndex = 0;
      this.resetForm();
    },
  };
}
</script>
</body>
</html>
